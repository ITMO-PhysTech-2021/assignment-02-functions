# Задание fun

В файлах `fun_recurrent.py` и `fun_args.py` даны заготовки функций, в которых вместо тела стоит `pass` или же
незавершенная реализация.

Ваша задача &ndash; реализовать их функциональность.

Функции, имя которых начинается с `__` &ndash; вспомогательные. Их не следует изменять, однако их следует использовать в
соответствии с указаниями в задании.

**Совет:** попробуйте понять, как устроены вспомогательные функции и что они делают. Понимание принципа их работы
поможет понять, с какими аргументами их следует вызывать, чтобы добиться того или иного результата.

## Блок `recurrent`

###### fun_recurrent.py

Гарантируется, что целые числа, поступающие на вход функциям из этого блока, неотрицательны.

Все функции из этого блока обязаны возвращать результат вызова функции `__recurrent` от числа `n` и произвольных
параметров `stop_condition`, `tranform` и `value`.

Вам разрешено заменять только те параметры, которые указаны как  `Ellipsis`.

### `def identity(n)`

На вход функции подается целое неотрицательное число `n`. Верните число `n`.

### `def log2(n)`

На вход функции подается целое положительное число `n`. Верните округленный вниз двоичный логарифм числа `n`.

Встроенными функциями логарифма пользоваться нельзя.

Например, `log2(7) = 2`, а `log2(8) = 3`.

### `def push(n)`

На вход функции подается целое неотрицательное число `n`. Верните число 0, `n` раз обернутое в массив. В этом задании
полезно реализовать дополнительную функцию `_depth(item)`, которая принимает вложенный массив `item` и возвращает
&laquo;глубину&raquo; числа в нем.

Например, `push(1) = [0]` и `_depth([0]) = 1`, а `push(3) = [[[0]]]` и `_depth([[[0]]]) = 3`.

## Блок `args`

###### fun_args.py

Функции из этого блока чаще всего принимают `*args` и `**kwargs`. Первый позволяет передать в функцию сколько угодно
неименных аргументов, второй &ndash; сколько угодно именных. С `args` можно работать как с неизменяемым массивом,
с `kwargs` &ndash; как со словарем.

### `def log_args(*args, print, mode='list')`

На вход функции подается неопределенное количество аргументов `args` и строка `mode`, принимающая значения `args`
, `list` или `len`. Используя функцию `print`,

- в случае `mode = 'args'` выведите все аргументы из `args` через пробел, например, `1 2 3`
- в случае `mode = 'list'` выведите переданные аргументы как массив, например, `[1, 2, 3]`.
- в случае `mode = 'len'` выведите количество переданных аргументов, например, `3`

### `def smart_filter(items, **kwargs)`

На вход функции подается массив произвольных объектов `items` и неопределенное число именных аргументов `kwargs`.
Проверьте, что в `kwargs` есть либо только аргумент `include`, либо только аргумент `exclude`, и

- если в нем есть аргумент `exclude`, верните `items`, из которого удалили все элементы, соответствующие переданному в
  этом аргументе условию
- если в нем есть аргумент `include`, верните `items`, в котором оставили только элементы, соответствующие переданному в
  этом аргументе условию

Если есть оба условия `include` и `exclude` или нет ни одного из них, или если есть другие именованные аргументы,
верните `None`.

Например, `smart_filter([1, 2, 3, 4, 5], exclude=lambda x: x % 2 == 0)` должен вернуть `[1, 3, 5]`,
а `smart_filter([1, 2, 3, 4, 5], include=lambda x: x % 2 == 0)` должен вернуть `[2, 4]`.

### `def smart_map(*args, **kwargs)`

На вход функции подается неопределенное количество строк `args` и неопределенное количество именных аргументов `kwargs`.
Верните массив из исходных элементов, в котором каждая строка, совпадающая с именем какого-то именного аргумента,
заменяется на его значение (условие звучит жутко, но по примерам понятно).

Например, `smart_map('a', 'b', 'c', 'd', a=1, d='177')` возвращает `[1, 'b', 'c', '177']`,
а `smart_map('x', 'y', 'x', 'arg', arg='x', x=0)` возвращает `[0, 'y', 0, 'x']`.