# Задание exercise

В файле `exercise.py` даны заготовки различных функций, в которых вместо тела стоит `pass`.

Ваша задача &ndash; реализовать их функциональность.

Во всех заданиях, в которых одним из аргументов является другая функция, гарантируется, что она принимает столько
параметров, сколько заявлено в условии.

### `def twice(fun, arg)`

На вход функции подается функция от одного аргумента `fun` и аргумент `arg`. Верните результат двойного применения
функции `fun` к данному аргументу.

Например, `twice(lambda x: x + 1, 1)` должно возвращать `3`, а `twice(lambda x: x + [2], [1])` должно
возвращать `[1, 2, 2]`.

### `def foreach(funs, args)`

На вход функции подается массив других функций `funs` и массив такого же размера `args`. Верните массив, состоящий из
результатов применения функций `funs` к соответствующим аргументам, то есть первой функции к первому аргументу, второй
ко второму, и так далее.

Например, для `funs = [lambda x: x + 2, lambda x: x * 2, int]` и `args = [1, 2, '5']` вызов `foreach(funs, args)` должен
вернуть `[3, 4, 5]`.

### `def apply(fun, args, kwargs)`

На вход функции подается функция `fun`, массив `args` и словарь `kwargs`. Верните результат вызова функции `fun` с
данными аргументами.

Например, вызов `apply(fun, [1, 2, 3], {'sep': ':'})` должен быть эквивалентен вызову `fun(1, 2, 3, sep=':')`. В
частности, `apply(print, [1, 2, 3], {'sep': ':'})` должен выводить строку `1:2:3` и возвращать `None` (ничего).

**Совет:** поищите, как в питоне устроены конструкции передачи в функцию произвольного количества аргументов.

### `def all_ternary(n)`

На вход функции подается неотрицательное целое число `n`. Верните массив из `3 ** n` строк длины `n` &ndash; все числа от `0`
до `3 ** n - 1`, записанные в троичной системе счисления. Чтобы строки были длины `n`, их следует дополнять ведущими
нулями.

Например, `all_ternary(1)` должен вернуть `['0', '1', '2']`, а `all_ternary(2)` должен
вернуть `['00', '01', '02', '10', '11', '12', '20', '21', '22']`.

**Совет:** используйте рекурсию; проще генерировать ответ для `n`, уже имея ответ для `n - 1`.

### `def swap_arguments(fun)`

На вход функции подается функция от двух аргументов `fun`. Верните другую функцию, которая работает точно так же, как
и `fun`, но с обратным порядком аргументов. Иными словами, для любой функции `fun`, если
завести `fun2 = swap_arguments(fun)`, должно всегда выполняться `fun(a, b) = fun2(b, a)`.

Например, для `f = swap_arguments(lambda x, y: x - y)` должно выполняться `f(1, 2) = 1`, потому что это эквивалентно
вызову `2 - 1` из лямбды.

**Совет:** заведите внутри функции `swap_arguments()` локальную функцию, которая затем будет возвращаться в качестве
ответа. Можно при этом не заводить функцию в явном виде, а написать свою лямбду.