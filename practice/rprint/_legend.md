# Задание rprint

В файле `rprint.py` даны заготовки функций для &laquo;красивого&raquo; вывода глубоко вложенных массивов, в которых
вместо тела стоит `pass`.

Ваша задача &ndash; реализовать их функциональность.

Гарантируется, что на вход **не подаются** массивы, содержащие себя в качестве вложенного элемента, например получаемые
с помощью

```python
a = [1, 2]
a.append(a)
print(a)
# [1, 2, [...]]
```

**Совет:** функции в этом задании имеет смысл реализовывать с помощью _рекурсии_. Здесь она поможет сделать код намного
более простым и понятным.

### `def flatten(a)`

На вход функции подается массив `a`. Каждый его элемент &ndash; либо число, либо массив с такой же структурой. Верните
массив, состоящий из всех чисел, сколь угодно глубоко лежащих в `a`, в том порядке, в котором они следовали в `a`.

Например, `flatten([1, [], [2, [3, [4], 5]], [[[[6]]]]])` должен возвращать `[1, 2, 3, 4, 5, 6]`.

### `def rprint(a, depth, current_depth=0)`

На вход функции подается массив `a` описанной выше структуры и натуральное число `depth`. Верните строку, которая
является представлением массива `a` до глубины `depth`, то есть в которой

- любой **непустой** массив на глубине `depth` отображается как `[...]` (таким образом, элементы на глубине
  больше `depth` вообще не отображаются)
- любое число `number` на глубине не больше `depth` отображается своим стандартным строковым видом `str(number)`
- любой пустой масив на глубине не больше `depth` отображается своим стандартным строковым видом `[]`

Сам внешний массив `a` находится на глубине 0, его элементы &ndash; на глубине 1, их элементы &ndash; на глубине 2, и
так далее. Параметр `current_depth` можете использовать для определения того, на каком уровне вложенности сейчас
находитесь.

Например, `rprint([1, [2, [3, 4], 5], [[[6, [7]]]]], depth=2)` должен возвращать строку `'[1, [2, [...], 5], [[...]]]'`.
Здесь `1` и `[2, [3, 4], 5]` являются элементами первого уровня, а поэтому элементы `2`, `[3, 4]` и `5` находятся на
втором уровне (на глубине 2). Поэтому при `depth=2` массив `[3, 4]` заменяется на `'[...]'`.

### `def pretty_rprint(a, current_depth=0, print):`

На вход функции подается массив `a` описанной выше структуры. Выведите с помощью функции `print()` строковое
представление массива `a`, в котором

- перед элементами на глубине `depth` стоит ровно 4 &times; `depth` пробелов
- каждый массив, имеющий вложенные массивы, должен
    - начинаться с `[` с соответствующим отступом
    - продолжаться перечислением всех своих элементов с отступом на 4 пробела больше
    - заканчиваться `]` с тем же отступом, что и открывающая скобка
- каждый массив, состоящий только из чисел (в том числе пустой), должен занимать одну строку и состоять из `[`, всех
  своих элементов, и `]`, выписанных через пробел

Параметр `current_depth` можете использовать для определения того, на каком уровне вложенности сейчас находитесь.

Например, `pretty_rprint([[1, 2], [3], [[4], 5, [6, [7]]]])` должен выводить

```
[
    [ 1 2 ]
    [ 3 ]
    [
        [ 4 ]
        5
        [
            6
            [ 7 ]
        ]
    ]
]
```