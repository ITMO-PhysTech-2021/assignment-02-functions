# Задание fun_args

В файле `fun_args.py` даны заготовки функций, в которых вместо тела стоит `pass`.

Ваша задача &ndash; реализовать их функциональность.

Функции из этого задания принимают `*args` и/или `**kwargs`. Первый позволяет передать в функцию сколько угодно
неименнованных (позиционных) аргументов, второй &ndash; сколько угодно именованных. С `args` можно работать как с
неизменяемым массивом (тип `tuple`), с `kwargs` &ndash; как со словарем.

**Совет:** просто аккуратно реализуйте то, что требуется в задании, ничего не напутав. Если код получается длинным, то,
скорее всего, он может быть в пару раз короче. Если тяжело осознать условие, посмотрите на примеры, по ним должно стать
немного понятнее.

### `def log_args(*args, mode, print)`

На вход функции подается неопределенное количество аргументов `args` и строка `mode`, принимающая значения `args`
, `list` или `len`. Используя функцию `print`,

- в случае `mode = 'args'` выведите все аргументы из `args` через пробел, например, `1 2 3`
- в случае `mode = 'list'` выведите переданные аргументы как массив, например, `[1, 2, 3]`.
- в случае `mode = 'len'` выведите количество переданных аргументов, например, `3`

Например, `log_args(1, 2, 3, mode='args')` должен иметь вывод `1 2 3`, а `log_args(1, 2, 3, 4, 5, mode='list')`
должен вывести `[1, 2, 3, 4, 5]`.

### `def smart_filter(items, **kwargs)`

На вход функции подается массив произвольных объектов `items` и произвольное количество именованных аргументов `kwargs`.
Проверьте, что в `kwargs` не переданы никакие аргументы, кроме аргументов с именами `include` и `exclude`, и

- если передан аргумент `include`, выберите только те элементы `items`, которые удовлятворяют переданному в этом
  аргументе условию.
- если передан аргумент `exclude`, удалите из рассмотрения все те элементы, для которых выполняется переданное в этом
  аргументе условие

Если не передан ни один из этих двух аргументов, или если есть аргументы с другими именами, верните `None`. Считайте,
что любой переданный в `kwargs` аргумент &ndash; корректное условие.

Например, `smart_filter([1, 2, 3, 4, 5], exclude=lambda x: x % 2 == 0)` должен вернуть `[1, 3, 5]`,
а `smart_filter([1, 2, 3, 4, 5], include=lambda x: x < 4)` должен вернуть `[1, 2, 3]`.

Когда переданы оба аргумента, `smart_filter([1, 2, 3, 4, 5], include=lambda x: x < 4, exclude=lambda x: x % 2 == 0)`
возвращает `[1, 3]`.

В свою очередь `smart_filter([1, 2, 3], inexclude=lambda x: True)` должен вернуть `None`, так как передан аргумент с
неожиданным именем.

### `def smart_map(*args, **kwargs)`

На вход функции подается произвольное количество строк `args` и произвольное количество именованных аргументов `kwargs`.
Верните массив из исходных строк, в котором каждая строка, совпадающая с именем какого-то именованного аргумента,
заменяется на его значение.

Проверять, что каждому именованному аргументу соответствует какая-то строка из позиционных аргументов, не надо.

Например, `smart_map('a', 'b', 'c', a=1, d='177')` возвращает `[1, 'b', 'c']`, так как аргумент `a=1` говорит о замене
строки `a` на число `1`. А `smart_map('x', 'y', 'z', x='y', y=1)`, аналогично, возвращает `['y', 1, 'z']`.