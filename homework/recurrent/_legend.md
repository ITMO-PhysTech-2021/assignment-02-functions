# Задание recurrent

В файле `recurrent.py` даны заготовки функций, в которых вместо тела стоит незавершенная реализация.

Ваша задача &ndash; реализовать их функциональность.

Гарантируется, что целые числа, поступающие на вход функциям из этого задания, неотрицательны.

### Ограничения:

1. Все функции из этого блока обязаны возвращать результат вызова функции `__recurrent()` от числа `n` и некоторых
   параметров `stop_condition`, `tranform` и `value`.
2. Вам разрешено заменять только те параметры, которые указаны как  `Ellipsis`. Саму функцию `__recurrent()` менять
   нельзя.
3. Кроме как в качестве первого параметра для `__recurrent()`, использовать `n` нельзя. Например, в качестве `value`
   можно передать `lambda x: x`, но нельзя передать `lambda x: n`.

**Совет:** попробуйте понять, как устроена функция `__recurrent()` и что она делают. Можете в явном виде подставить в
нее какие-то простые преобразования и условия и проследить за ее исполнением.

### `def identity(n)`

На вход функции подается целое неотрицательное число `n`. Верните число `n`.

### `def log2(n)`

На вход функции подается целое положительное число `n`. Верните округленный вниз двоичный логарифм числа `n`.
Встроенными функциями логарифма пользоваться нельзя.

Например, `log2(7) = 2`, а `log2(8) = 3`.

### `def push(n)`

На вход функции подается целое неотрицательное число `n`. Верните число 0, `n` раз обернутое в массив (см. примеры). В
этом задании полезно реализовать дополнительную функцию `__depth(item)`, которая принимает вложенный массив `item` и
возвращает &laquo;глубину&raquo; числа в нем.

Например, `push(1) = [0]` и `__depth([0]) = 1`, а `push(3) = [[[0]]]` и `__depth([[[0]]]) = 3`.